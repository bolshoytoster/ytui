//! Structures returned from the general 'browse' request

#![allow(non_snake_case)]

use ratatui::style::{Modifier, Style};
use ratatui::text;
use ratatui::text::Spans;
use ratatui::widgets::{ListItem, Paragraph, Wrap};
use serde::Deserialize;

use super::*;

#[derive(Deserialize)]
struct ChipCloudChipRenderer {
	// This isn't present on the selected tag
	navigationEndpoint: Option<ContinuationEndpoint>,
	text: Text,
	// Ignore `style`, `trackingParams` and sometimes `isSelected` and targetId
}

#[derive(Deserialize)]
struct FeedFilterChipBarRendererContent {
	chipCloudChipRenderer: ChipCloudChipRenderer,
}

#[derive(Deserialize)]
struct FeedFilterChipBarRenderer {
	contents: Vec<FeedFilterChipBarRendererContent>,
	// Ignore `nextButton`, `previousButton`, `styleType` and `trackingParams`
}

#[derive(Deserialize)]
struct RichGridRendererHeader {
	feedFilterChipBarRenderer: FeedFilterChipBarRenderer,
}

#[derive(Deserialize)]
pub struct RichGridRenderer {
	contents: Vec<RichGridRendererContent>,
	header: RichGridRendererHeader,
	// Ignore `reflowOptions`, `targetId` and `trackingParams`
}
impl RichGridRenderer {
	pub fn into_widgets<'a>(
		self,
	) -> (
		Vec<ListItem<'a>>,
		Vec<(Paragraph<'a>, Node)>,
		Option<String>,
	) {
		// Total number of items
		let len = self.header.feedFilterChipBarRenderer.contents.len() + self.contents.len();

		let mut titles = Vec::with_capacity(len);
		let mut info = Vec::with_capacity(len);

		// Continuation token
		let mut continuation = None;

		for content in self.header.feedFilterChipBarRenderer.contents {
			titles.push(ListItem::new(
				content.chipCloudChipRenderer.text.with_style(Style {
					add_modifier: if let Some(navigation_endpoint) =
						content.chipCloudChipRenderer.navigationEndpoint
					{
						// Normal, most tabs
						// Add this tab (no description)
						info.push((
							Paragraph::new(EMPTY_TEXT),
							Node::Header(navigation_endpoint.continuationCommand.token),
						));

						// No modifier
						Modifier::empty()
					} else {
						// The selected tab
						// Add empty item
						info.push((Paragraph::new(EMPTY_TEXT), Node::None));

						// Underline
						Modifier::BOLD
					},
					..Style::default()
				}),
			));
		}

		// Empty line
		titles.push(ListItem::new(text::Text {
			lines: vec![Spans(Vec::new())],
		}));
		info.push((Paragraph::new(EMPTY_TEXT), Node::None));

		for content in self.contents {
			if let Some(continuation_token) = content.into_widgets(&mut titles, &mut info) {
				continuation = Some(continuation_token);
			}
		}

		(titles, info, continuation)
	}
}

#[derive(Deserialize)]
struct SectionListRendererContent {
	itemSectionRenderer: ItemSectionRenderer,
}

#[derive(Deserialize)]
struct SectionListRenderer {
	contents: Vec<SectionListRendererContent>, // Ignore `targetID` and `trackingParams`
}

#[derive(Deserialize)]
struct TabRendererContent {
	sectionListRenderer: SectionListRenderer,
}

#[derive(Deserialize)]
struct TabRenderer {
	content: Option<TabRendererContent>,
}

#[derive(Deserialize)]
struct Tab {
	tabRenderer: TabRenderer,
}

#[derive(Deserialize)]
struct TwoColumnBrowseResultsRenderer {
	tabs: Vec<Tab>,
}

#[derive(Deserialize)]
struct Contents {
	twoColumnBrowseResultsRenderer: TwoColumnBrowseResultsRenderer,
}

#[derive(Deserialize)]
struct InteractiveTabbedHeaderRenderer {
	title: SimpleText,
	description: SimpleText,
	metadata: Text,
	badges: Vec<Badge<MetadataBadgeRendererVideo>>,
	// Ignore `type`, `boxArt`, `banner`, `buttons` and `autoGenerated`
}

#[derive(Deserialize)]
struct C4TabbedHeaderRenderer {
	title: String,
	// Ignore `avatar` and `trackingParams`
}

#[derive(Deserialize)]
struct TopicChannelDetailsRenderer {
	title: SimpleText,
	subtitle: AccessibleText,
	navigationEndpoint: Endpoint,
	// Ignore `avatar`, `subscribeButton` and `trackingParams`
}

#[derive(Deserialize)]
struct InlinePlaybackRendererInner {
	lengthText: AccessibleText,
	videoId: String,
	// Ignore `inlinePlaybackEndpoint`, `navigationEndpoint`, `thumbnail` and `trackingParams`
}

#[derive(Deserialize)]
struct InlinePlaybackRendererOuter {
	inlinePlaybackRenderer: InlinePlaybackRendererInner,
}

#[derive(Deserialize)]
struct DefaultPromoPanelRenderer {
	description: Text,
	inlinePlaybackRenderer: InlinePlaybackRendererOuter,
	title: Text,
	// Ignore `actionButton`, `largeFormFactorBackgroundThumbnail`, `metadataOrder`,
	// `minPanelDisplayDurationMs`, `minVideoPlayDurationMs`, `navigationEndpoint`, `panelLayout`,
	// `scrimColorValues` `smallFormFactorBackgroundThumbnail` and `trackingParams`
}

#[derive(Deserialize)]
struct CarouselItem {
	defaultPromoPanelRenderer: DefaultPromoPanelRenderer,
}

#[derive(Deserialize)]
struct CarouselItemRenderer {
	carouselItems: Vec<CarouselItem>,
	// Ignore `backgroundColor`, `layoutStyle`, `paginationThumbnails`, `paginatorAlignment` and
	// `trackingParams`
}

#[derive(Deserialize)]
#[serde(untagged)]
enum CarouselHeaderRendererContent {
	TopicChannelDetails {
		topicChannelDetailsRenderer: TopicChannelDetailsRenderer,
	},
	CarouselItem {
		carouselItemRenderer: CarouselItemRenderer,
	},
}

#[derive(Deserialize)]
struct CarouselHeaderRenderer {
	contents: Vec<CarouselHeaderRendererContent>, // Ignore `trackingParams`
}

#[derive(Deserialize)]
#[serde(untagged)]
enum GeneralResponseHeader {
	InteractiveTabbed {
		interactiveTabbedHeaderRenderer: InteractiveTabbedHeaderRenderer,
	},
	C4Tabbed {
		c4TabbedHeaderRenderer: C4TabbedHeaderRenderer,
	},
	Carousel {
		carouselHeaderRenderer: CarouselHeaderRenderer,
	},
}

/// A few requests have this
#[derive(Deserialize)]
pub struct GeneralResponse {
	contents: Contents,
	header: GeneralResponseHeader,
	// Ignore `frameworkUpdates`, `responseContext`, `topbar` and `trackingParams`
}
impl GeneralResponse {
	pub fn into_widgets<'a>(
		self,
	) -> (
		Vec<ListItem<'a>>,
		Vec<(Paragraph<'a>, Node)>,
		Option<String>,
	) {
		// Total number of items
		let len =
			self.contents
				.twoColumnBrowseResultsRenderer
				.tabs
				.iter()
				.map(|tab| {
					tab.tabRenderer
						.content
						.as_ref()
						.map_or(0, |content| content.sectionListRenderer.contents.len())
				})
				.sum::<usize>() + 1;

		let mut titles = Vec::with_capacity(len);
		let mut info = Vec::with_capacity(len);

		// Used for continuation
		let mut continuation = None;

		match self.header {
			GeneralResponseHeader::InteractiveTabbed {
				interactiveTabbedHeaderRenderer,
			} => {
				titles.push(underlined(interactiveTabbedHeaderRenderer.title.simpleText));

				info.push((
					Paragraph::new(vec![
						interactiveTabbedHeaderRenderer.metadata.into(),
						"".into(),
						interactiveTabbedHeaderRenderer
							.description
							.simpleText
							.into(),
						"".into(),
						[
							"Badges: ",
							&interactiveTabbedHeaderRenderer
								.badges
								.into_iter()
								.map(|badge| badge.metadataBadgeRenderer.label)
								.collect::<String>(),
						]
						.concat()
						.into(),
					])
					.wrap(Wrap { trim: false }),
					Node::None,
				));
			}
			GeneralResponseHeader::C4Tabbed {
				c4TabbedHeaderRenderer,
			} => {
				titles.push(underlined(c4TabbedHeaderRenderer.title));

				info.push((Paragraph::new(EMPTY_TEXT), Node::None));
			}
			GeneralResponseHeader::Carousel {
				carouselHeaderRenderer,
			} => {
				for content in carouselHeaderRenderer.contents {
					match content {
						CarouselHeaderRendererContent::TopicChannelDetails {
							topicChannelDetailsRenderer,
						} => {
							titles.push(underlined(topicChannelDetailsRenderer.title.simpleText));

							info.push((
								Paragraph::new(
									topicChannelDetailsRenderer
										.subtitle
										.accessibility
										.accessibilityData
										.label,
								)
								.wrap(Wrap { trim: false }),
								Node::Game(
									topicChannelDetailsRenderer
										.navigationEndpoint
										.browseEndpoint
										.browseId,
									None,
								),
							));
						}
						CarouselHeaderRendererContent::CarouselItem {
							carouselItemRenderer,
						} => {
							for carousel_item in carouselItemRenderer.carouselItems {
								titles.push(spaced(carousel_item.defaultPromoPanelRenderer.title));

								info.push((
									Paragraph::new(vec![
										carousel_item.defaultPromoPanelRenderer.description.into(),
										"".into(),
										[
											"Length: ",
											&carousel_item
												.defaultPromoPanelRenderer
												.inlinePlaybackRenderer
												.inlinePlaybackRenderer
												.lengthText
												.accessibility
												.accessibilityData
												.label,
										]
										.concat()
										.into(),
									])
									.wrap(Wrap { trim: false }),
									Node::Video(
										carousel_item
											.defaultPromoPanelRenderer
											.inlinePlaybackRenderer
											.inlinePlaybackRenderer
											.videoId,
									),
								));
							}
						}
					}
				}
			}
		}

		// Only one tab actually has content, but we have to check each one just in case
		for tab in self.contents.twoColumnBrowseResultsRenderer.tabs {
			if let Some(tab_renderer_content) = tab.tabRenderer.content {
				for section_list_renderer_content in
					tab_renderer_content.sectionListRenderer.contents
				{
					for item_section_renderer_content in
						section_list_renderer_content.itemSectionRenderer.contents
					{
						match item_section_renderer_content {
							ItemSectionRendererContent::ShelfRenderer { shelfRenderer } => {
								if let Some(new_continuation) =
									shelfRenderer.into_widgets(&mut titles, &mut info)
								{
									continuation = Some(new_continuation);
								}
							}
							ItemSectionRendererContent::ReelShelfRenderer { reelShelfRenderer } => {
								reelShelfRenderer.into_widgets(&mut titles, &mut info)
							}
							ItemSectionRendererContent::HorizontalCardList {
								horizontalCardListRenderer,
							} => horizontalCardListRenderer.into_widgets(&mut titles, &mut info),
						}
					}
				}
			}
		}

		(titles, info, continuation)
	}
}
